<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML>
<HEAD>
	<META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset=gb2312">
	<TITLE></TITLE>
	<META NAME="GENERATOR" CONTENT="OpenOffice.org 2.0  (Linux)">
	<META NAME="CREATED" CONTENT="20060729;13242100">
	<META NAME="CHANGED" CONTENT="16010101;8042600">
	<STYLE>
	<!--
		@page { size: 21cm 29.7cm; margin: 2cm }
		P { margin-bottom: 0.21cm; direction: ltr; color: #000000; text-align: left; widows: 0; orphans: 0 }
		P.western { font-family: "AR PL ZenKai Uni", serif; font-size: 12pt; so-language: en-US }
		P.cjk { font-family: "AR PL ShanHeiSun Uni"; font-size: 12pt; so-language: zh-CN }
		P.ctl { font-family: "AR PL ShanHeiSun Uni"; font-size: 12pt; so-language:  }
		H1 { margin-bottom: 0.21cm; direction: ltr; color: #000000; text-align: left; widows: 0; orphans: 0 }
		H1.western { font-family: "AR PL ZenKai Uni", serif; so-language: en-US }
		H1.cjk { font-family: "AR PL ShanHeiSun Uni"; font-size: 24pt; so-language: zh-CN; font-style: normal; font-weight: bold }
		H1.ctl { font-family: "AR PL ShanHeiSun Uni"; font-size: 24pt; so-language: ; font-weight: bold }
		H3 { margin-bottom: 0.21cm; direction: ltr; color: #000000; text-align: left; widows: 0; orphans: 0 }
		H3.western { font-family: "AR PL ZenKai Uni", serif; so-language: en-US }
		H3.cjk { font-family: "AR PL ShanHeiSun Uni"; so-language: zh-CN; font-style: normal }
		H3.ctl { font-family: "AR PL ShanHeiSun Uni"; so-language:  }
		H4 { margin-bottom: 0.21cm; direction: ltr; color: #000000; text-align: left; widows: 0; orphans: 0 }
		H4.western { font-family: "AR PL ZenKai Uni", serif; so-language: en-US }
		H4.cjk { font-family: "AR PL ShanHeiSun Uni"; so-language: zh-CN; font-style: normal }
		H4.ctl { font-family: "AR PL ShanHeiSun Uni"; so-language:  }
		TD P { margin-bottom: 0cm; direction: ltr; color: #000000; text-align: left; widows: 0; orphans: 0 }
		TD P.western { font-family: "AR PL ZenKai Uni", serif; font-size: 12pt; so-language: en-US }
		TD P.cjk { font-family: "AR PL ShanHeiSun Uni"; font-size: 12pt; so-language: zh-CN }
		TD P.ctl { font-family: "AR PL ShanHeiSun Uni"; font-size: 12pt; so-language:  }
	-->
	</STYLE>
</HEAD>
<BODY LANG="zh-CN" TEXT="#000000" DIR="LTR">
<H1 CLASS="cjk" ALIGN=CENTER><B><SPAN LANG="zh-CN"><FONT SIZE=6><FONT COLOR="#000000">瑞士军刀──</FONT></FONT></SPAN></B><FONT FACE="AR PL ZenKai Uni, serif"><SPAN LANG="en-US"><B><SPAN LANG="en-US"><FONT SIZE=6><FONT COLOR="#000000">Valgrind</FONT></FONT></SPAN></B></SPAN></FONT></H1>

<P CLASS="cjk">   <FONT FACE="AR PL ZenKai Uni, serif"><SPAN LANG="en-US">Valgrind</SPAN></FONT>的主要作者<FONT FACE="AR PL ZenKai Uni, serif"><SPAN LANG="en-US">Julian
Seward</SPAN></FONT>曾获得了<FONT FACE="AR PL ZenKai Uni, serif"><SPAN LANG="en-US">Google-O'Reilly</SPAN></FONT>开源大奖之一──<FONT FACE="AR PL ZenKai Uni, serif"><SPAN LANG="en-US">Best
Tool
Maker</SPAN></FONT>。让我们一起来看一下他的作品。<FONT FACE="AR PL ZenKai Uni, serif"><SPAN LANG="en-US">Valgrind</SPAN></FONT>是运行在<FONT FACE="AR PL ZenKai Uni, serif"><SPAN LANG="en-US">Linux</SPAN></FONT>上一套基于仿真技术的程序调试和分析工具，它包含一个内核──一个软件合成的<FONT FACE="AR PL ZenKai Uni, serif"><SPAN LANG="en-US">CPU</SPAN></FONT>，和一系列的小工具，每个工具都可以完成一项任务──调试，分析，或测试等。<FONT FACE="AR PL ZenKai Uni, serif"><SPAN LANG="en-US">Valgrind</SPAN></FONT>可以检测内存泄漏和内存违例，还可以分析<FONT FACE="AR PL ZenKai Uni, serif"><SPAN LANG="en-US">cache</SPAN></FONT>的使用等，灵活轻巧而又强大，能直穿程序错误的心脏，真可谓是程序员的瑞士军刀。
</P>
<H3 CLASS="cjk"><B><SPAN LANG="zh-CN"><FONT SIZE=4><FONT COLOR="#000000">一</FONT></FONT></SPAN></B><FONT FACE="AR PL ZenKai Uni, serif"><SPAN LANG="en-US"><B><SPAN LANG="en-US"><FONT SIZE=4><FONT COLOR="#000000">.
Valgrind</FONT></FONT></SPAN></B></SPAN></FONT><B><SPAN LANG="zh-CN"><FONT SIZE=4><FONT COLOR="#000000">概观</FONT></FONT></SPAN></B></H3>
<P CLASS="cjk">    <FONT FACE="AR PL ZenKai Uni, serif"><SPAN LANG="en-US">Valgrind</SPAN></FONT>的最新版是<FONT FACE="AR PL ZenKai Uni, serif"><SPAN LANG="en-US">3.2.0</SPAN></FONT>，它一般包含下列工具：
</P>
<H4 CLASS="cjk"><FONT FACE="AR PL ZenKai Uni, serif"><FONT SIZE=3><SPAN LANG="en-US"><B>1.Memcheck</B></SPAN></FONT></FONT></H4>
<P CLASS="cjk">     最常用的工具，用来检测程序中出现的内存问题，所有对内存的读写都会被检测到，
一切对<FONT FACE="AR PL ZenKai Uni, serif"><SPAN LANG="en-US">malloc()/free()/new/delete</SPAN></FONT>的调用都会被捕获。所以，它能检测以下问题：</P>
<P CLASS="cjk"><FONT FACE="AR PL ZenKai Uni, serif"><SPAN LANG="en-US">1.</SPAN></FONT>对未初始化内存的使用；</P>
<P CLASS="cjk"><FONT FACE="AR PL ZenKai Uni, serif"><SPAN LANG="en-US">2.</SPAN></FONT>读<FONT FACE="AR PL ZenKai Uni, serif"><SPAN LANG="en-US">/</SPAN></FONT>写释放后的内存块；</P>
<P CLASS="cjk"><FONT FACE="AR PL ZenKai Uni, serif"><SPAN LANG="en-US">3.</SPAN></FONT>读<FONT FACE="AR PL ZenKai Uni, serif"><SPAN LANG="en-US">/</SPAN></FONT>写超出<FONT FACE="AR PL ZenKai Uni, serif"><SPAN LANG="en-US">malloc</SPAN></FONT>分配的内存块；</P>
<P CLASS="cjk"><FONT FACE="AR PL ZenKai Uni, serif"><SPAN LANG="en-US">4.</SPAN></FONT>读<FONT FACE="AR PL ZenKai Uni, serif"><SPAN LANG="en-US">/</SPAN></FONT>写不适当的栈中内存块；</P>
<P CLASS="cjk"><FONT FACE="AR PL ZenKai Uni, serif"><SPAN LANG="en-US">5.</SPAN></FONT>内存泄漏，指向一块内存的指针永远丢失；</P>
<P CLASS="cjk"><FONT FACE="AR PL ZenKai Uni, serif"><SPAN LANG="en-US">6.</SPAN></FONT>不正确的<FONT FACE="AR PL ZenKai Uni, serif"><SPAN LANG="en-US">malloc/free</SPAN></FONT>或<FONT FACE="AR PL ZenKai Uni, serif"><SPAN LANG="en-US">new/delete</SPAN></FONT>匹配；</P>
<P CLASS="cjk"><FONT FACE="AR PL ZenKai Uni, serif"><SPAN LANG="en-US">7,memcpy()</SPAN></FONT>相关函数中的<FONT FACE="AR PL ZenKai Uni, serif"><SPAN LANG="en-US">dst</SPAN></FONT>和<FONT FACE="AR PL ZenKai Uni, serif"><SPAN LANG="en-US">src</SPAN></FONT>指针重叠。</P>
<P CLASS="cjk">这些问题往往是<FONT FACE="AR PL ZenKai Uni, serif"><SPAN LANG="en-US">C/C++</SPAN></FONT>程序员最头疼的问题，<FONT FACE="AR PL ZenKai Uni, serif"><SPAN LANG="en-US">Memcheck</SPAN></FONT>在这里帮上了大忙。</P>
<H4 CLASS="cjk"><FONT FACE="AR PL ZenKai Uni, serif"><FONT SIZE=3><SPAN LANG="en-US"><B>2.Callgrind</B></SPAN></FONT></FONT></H4>
<P CLASS="cjk" STYLE="margin-bottom: 0cm">   
和<FONT FACE="AR PL ZenKai Uni, serif"><SPAN LANG="en-US">gprof</SPAN></FONT>类似的分析工具，但它对程序的运行观察更是入微，能给我们提供更多的信息。和<FONT FACE="AR PL ZenKai Uni, serif"><SPAN LANG="en-US">gprof</SPAN></FONT>不同，它不需要在编译源代码时附加特殊选项，但加上调试选项是推荐的。<FONT FACE="AR PL ZenKai Uni, serif"><SPAN LANG="en-US">Callgrind</SPAN></FONT>收集程序运行时的一些数据，建立函数调用关系图，还可以有选择地进行<FONT FACE="AR PL ZenKai Uni, serif"><SPAN LANG="en-US">cache</SPAN></FONT>模拟。在运行结束时，它会把分析数据写入一个文件。<FONT FACE="AR PL ZenKai Uni, serif"><SPAN LANG="en-US">callgrind_annotate</SPAN></FONT>可以把这个文件的内容转化成可读的形式。</P>
<H4 CLASS="cjk"><FONT FACE="AR PL ZenKai Uni, serif"><FONT SIZE=3><SPAN LANG="en-US"><B>3.Cachegrind</B></SPAN></FONT></FONT></H4>
<P CLASS="cjk" STYLE="margin-bottom: 0cm">   
<FONT FACE="AR PL ZenKai Uni, serif"><SPAN LANG="en-US">Cache</SPAN></FONT>分析器，它模拟<FONT FACE="AR PL ZenKai Uni, serif"><SPAN LANG="en-US">CPU</SPAN></FONT>中的一级缓存<FONT FACE="AR PL ZenKai Uni, serif"><SPAN LANG="en-US">I1</SPAN></FONT>，<FONT FACE="AR PL ZenKai Uni, serif"><SPAN LANG="en-US">Dl</SPAN></FONT>和二级缓存，能够精确地指出程序中<FONT FACE="AR PL ZenKai Uni, serif"><SPAN LANG="en-US">cache</SPAN></FONT>的丢失和命中。如果需要，它还能够为我们提供<FONT FACE="AR PL ZenKai Uni, serif"><SPAN LANG="en-US">cache</SPAN></FONT>丢失次数，内存引用次数，以及每行代码，每个函数，每个模块，整个程序产生的指令数。这对优化程序有很大的帮助。</P>
<H4 CLASS="cjk"><FONT FACE="AR PL ZenKai Uni, serif"><FONT SIZE=3><SPAN LANG="en-US"><B>4.Helgrind</B></SPAN></FONT></FONT></H4>
<P CLASS="cjk" STYLE="margin-bottom: 0cm">   
它主要用来检查多线程程序中出现的竞争问题。<FONT FACE="AR PL ZenKai Uni, serif"><SPAN LANG="en-US">Helgrind</SPAN></FONT>寻找内存中被多个线程访问，而又没有一贯加锁的区域，这些区域往往是线程之间失去同步的地方，而且会导致难以发掘的错误。<FONT FACE="AR PL ZenKai Uni, serif"><SPAN LANG="en-US">Helgrind</SPAN></FONT>实现了名为&ldquo;<FONT FACE="AR PL ZenKai Uni, serif"><SPAN LANG="en-US">Eraser&rdquo;</SPAN></FONT>的竞争检测算法，并做了进一步改进，减少了报告错误的次数。不过，<FONT FACE="AR PL ZenKai Uni, serif"><SPAN LANG="en-US">Helgrind</SPAN></FONT>仍然处于实验阶段。</P>
<H4 CLASS="cjk"><FONT FACE="AR PL ZenKai Uni, serif"><FONT SIZE=3><SPAN LANG="en-US"><B>5.
Massif</B></SPAN></FONT></FONT></H4>
<P CLASS="cjk" STYLE="margin-bottom: 0cm">   
堆栈分析器，它能测量程序在堆栈中使用了多少内存，告诉我们堆块，堆管理块和栈的大小。<FONT FACE="AR PL ZenKai Uni, serif"><SPAN LANG="en-US">Massif</SPAN></FONT>能帮助我们减少内存的使用，在带有虚拟内存的现代系统中，它还能够加速我们程序的运行，减少程序停留在交换区中的几率。</P>
<P CLASS="cjk" STYLE="margin-bottom: 0cm"><BR>
</P>
<P CLASS="cjk" STYLE="margin-bottom: 0cm">此外，<FONT FACE="AR PL ZenKai Uni, serif"><SPAN LANG="en-US">lackey</SPAN></FONT>和<FONT FACE="AR PL ZenKai Uni, serif"><SPAN LANG="en-US">nulgrind</SPAN></FONT>也会提供。<FONT FACE="AR PL ZenKai Uni, serif"><SPAN LANG="en-US">Lackey</SPAN></FONT>是小型工具，很少用到；<FONT FACE="AR PL ZenKai Uni, serif"><SPAN LANG="en-US">Nulgrind</SPAN></FONT>只是为开发者展示如何创建一个工具。我们就不做介绍了。</P>
<H3 CLASS="cjk"><B><SPAN LANG="zh-CN"><FONT SIZE=4><FONT COLOR="#000000">二</FONT></FONT></SPAN></B><FONT FACE="AR PL ZenKai Uni, serif"><SPAN LANG="en-US"><B><SPAN LANG="en-US"><FONT SIZE=4><FONT COLOR="#000000">.
</FONT></FONT></SPAN></B></SPAN></FONT><B><SPAN LANG="zh-CN"><FONT SIZE=4><FONT COLOR="#000000">使用</FONT></FONT></SPAN></B><FONT FACE="AR PL ZenKai Uni, serif"><SPAN LANG="en-US"><B><SPAN LANG="en-US"><FONT SIZE=4><FONT COLOR="#000000">Valgrind</FONT></FONT></SPAN></B></SPAN></FONT></H3>
<P CLASS="cjk" STYLE="margin-bottom: 0cm">   
<FONT FACE="AR PL ZenKai Uni, serif"><SPAN LANG="en-US">Valgrind</SPAN></FONT>的使用非常简单，<FONT FACE="AR PL ZenKai Uni, serif"><SPAN LANG="en-US">valgrind</SPAN></FONT>命令的格式如下：</P>
<P CLASS="cjk" STYLE="margin-bottom: 0cm"><FONT FACE="AR PL ZenKai Uni, serif"><SPAN LANG="en-US">	valgrind
[valgrind-options] your-prog [your-prog options]</SPAN></FONT></P>
<P CLASS="cjk" STYLE="margin-bottom: 0cm">一些常用的选项如下：</P>
<TABLE WIDTH=644 BORDER=1 BORDERCOLOR="#000000" CELLPADDING=4 CELLSPACING=0>
	<COL WIDTH=314>
	<COL WIDTH=312>
	<THEAD>
		<TR VALIGN=TOP>
			<TD WIDTH=314>
				<P CLASS="cjk" ALIGN=CENTER><FONT SIZE=3><B>选项</B></FONT></P>
			</TD>
			<TD WIDTH=312>
				<P CLASS="cjk" ALIGN=CENTER><FONT SIZE=3><B>作用</B></FONT></P>
			</TD>
		</TR>
	</THEAD>
	<TBODY>
		<TR VALIGN=TOP>
			<TD WIDTH=314>
				<P CLASS="cjk"><FONT FACE="AR PL ZenKai Uni, serif"><SPAN LANG="en-US">-h
				--help</SPAN></FONT></P>
			</TD>
			<TD WIDTH=312>
				<P CLASS="cjk">显示帮助信息。</P>
			</TD>
		</TR>
		<TR VALIGN=TOP>
			<TD WIDTH=314>
				<P CLASS="cjk"><FONT FACE="AR PL ZenKai Uni, serif"><SPAN LANG="en-US">--version</SPAN></FONT></P>
			</TD>
			<TD WIDTH=312>
				<P CLASS="cjk">显示<FONT FACE="AR PL ZenKai Uni, serif"><SPAN LANG="en-US">valgrind</SPAN></FONT>内核的版本，每个工具都有各自的版本。</P>
			</TD>
		</TR>
		<TR VALIGN=TOP>
			<TD WIDTH=314>
				<P CLASS="cjk"><FONT FACE="AR PL ZenKai Uni, serif"><SPAN LANG="en-US">-q
				--quiet</SPAN></FONT></P>
			</TD>
			<TD WIDTH=312>
				<P CLASS="cjk">安静地运行，只打印错误信息。</P>
			</TD>
		</TR>
		<TR VALIGN=TOP>
			<TD WIDTH=314>
				<P CLASS="cjk"><FONT FACE="AR PL ZenKai Uni, serif"><SPAN LANG="en-US">-v
				--verbose</SPAN></FONT></P>
			</TD>
			<TD WIDTH=312>
				<P CLASS="cjk">打印更详细的信息。</P>
			</TD>
		</TR>
		<TR VALIGN=TOP>
			<TD WIDTH=314>
				<P CLASS="cjk"><FONT FACE="AR PL ZenKai Uni, serif"><SPAN LANG="en-US">--tool=&lt;<I>toolname</I>&gt;
				[default: memcheck]</SPAN></FONT></P>
			</TD>
			<TD WIDTH=312>
				<P CLASS="cjk">最常用的选项。运行<FONT FACE="AR PL ZenKai Uni, serif"><SPAN LANG="en-US">valgrind</SPAN></FONT>中名为<FONT FACE="AR PL ZenKai Uni, serif"><SPAN LANG="en-US"><I>toolname</I></SPAN></FONT>的工具。如果省略工具名，默认运行<FONT FACE="AR PL ZenKai Uni, serif"><SPAN LANG="en-US">memcheck</SPAN></FONT>。</P>
			</TD>
		</TR>
		<TR VALIGN=TOP>
			<TD WIDTH=314>
				<P CLASS="cjk"><FONT FACE="AR PL ZenKai Uni, serif"><SPAN LANG="en-US">--db-attach=&lt;yes|no&gt;
				[default: no]</SPAN></FONT></P>
			</TD>
			<TD WIDTH=312>
				<P CLASS="cjk">绑定到调试器上，便于调试错误。</P>
			</TD>
		</TR>
	</TBODY>
</TABLE>
<P CLASS="cjk" STYLE="margin-bottom: 0cm">我们通过例子看一下它的具体使用。我们构造一个存在内存泄漏的<FONT FACE="AR PL ZenKai Uni, serif"><SPAN LANG="en-US">C</SPAN></FONT>程序，如下：</P>
<P CLASS="cjk" STYLE="margin-bottom: 0cm"><FONT FACE="AR PL ZenKai Uni, serif"><SPAN LANG="en-US">#include
&lt;stdlib.h&gt;</SPAN></FONT></P>
<P CLASS="cjk" STYLE="margin-bottom: 0cm"><FONT FACE="AR PL ZenKai Uni, serif"><SPAN LANG="en-US">#include
&lt;stdio.h&gt;</SPAN></FONT></P>
<P CLASS="cjk" STYLE="margin-bottom: 0cm"><FONT FACE="AR PL ZenKai Uni, serif"><SPAN LANG="en-US">void
f(void)</SPAN></FONT></P>
<P CLASS="cjk" STYLE="margin-bottom: 0cm"><FONT FACE="AR PL ZenKai Uni, serif"><SPAN LANG="en-US">{</SPAN></FONT></P>
<P CLASS="cjk" STYLE="margin-bottom: 0cm">  <FONT FACE="AR PL ZenKai Uni, serif"><SPAN LANG="en-US">int*
x = malloc(10 * sizeof(int));</SPAN></FONT></P>
<P CLASS="cjk" STYLE="margin-bottom: 0cm">  <FONT FACE="AR PL ZenKai Uni, serif"><SPAN LANG="en-US">x[10]
= 0;      // problem 1: heap block overrun</SPAN></FONT></P>
<P CLASS="cjk" STYLE="margin-bottom: 0cm"><FONT FACE="AR PL ZenKai Uni, serif"><SPAN LANG="en-US">}
              // problem 2: memory leak -- x not freed</SPAN></FONT></P>
<P CLASS="cjk" STYLE="margin-bottom: 0cm"><FONT FACE="AR PL ZenKai Uni, serif"><SPAN LANG="en-US">int
main(void)</SPAN></FONT></P>
<P CLASS="cjk" STYLE="margin-bottom: 0cm"><FONT FACE="AR PL ZenKai Uni, serif"><SPAN LANG="en-US">{</SPAN></FONT></P>
<P CLASS="cjk" STYLE="margin-bottom: 0cm">  <FONT FACE="AR PL ZenKai Uni, serif"><SPAN LANG="en-US">int
i;</SPAN></FONT></P>
<P CLASS="cjk" STYLE="margin-bottom: 0cm">  <FONT FACE="AR PL ZenKai Uni, serif"><SPAN LANG="en-US">f();</SPAN></FONT></P>
<P CLASS="cjk" STYLE="margin-bottom: 0cm">  <FONT FACE="AR PL ZenKai Uni, serif"><SPAN LANG="en-US">printf(&quot;i=%d\n&quot;,i);
//problem 3: use uninitialised value.</SPAN></FONT></P>
<P CLASS="cjk" STYLE="margin-bottom: 0cm">  <FONT FACE="AR PL ZenKai Uni, serif"><SPAN LANG="en-US">return
0;</SPAN></FONT></P>
<P CLASS="cjk" STYLE="margin-bottom: 0cm"><FONT FACE="AR PL ZenKai Uni, serif"><SPAN LANG="en-US">}</SPAN></FONT></P>
<P CLASS="cjk" STYLE="margin-bottom: 0cm">保存为<FONT FACE="AR PL ZenKai Uni, serif"><SPAN LANG="en-US">memleak.c</SPAN></FONT>并编译，然后用<FONT FACE="AR PL ZenKai Uni, serif"><SPAN LANG="en-US">valgrind</SPAN></FONT>检测。</P>
<P CLASS="cjk" STYLE="margin-bottom: 0cm"><FONT FACE="AR PL ZenKai Uni, serif"><SPAN LANG="en-US">$
gcc -Wall -o memleak memleak.c</SPAN></FONT></P>
<P CLASS="cjk" STYLE="margin-bottom: 0cm"><FONT FACE="AR PL ZenKai Uni, serif"><SPAN LANG="en-US">$
valgrind --tool=memcheck ./memleak</SPAN></FONT></P>
<P CLASS="cjk" STYLE="margin-bottom: 0cm">我们得到如下错误信息：</P>
<P CLASS="cjk" STYLE="margin-bottom: 0cm"><BR>
</P>
<P CLASS="cjk" STYLE="margin-bottom: 0cm"><FONT FACE="AR PL ZenKai Uni, serif"><SPAN LANG="en-US">==3649==
Invalid write of size 4</SPAN></FONT></P>
<P CLASS="cjk" STYLE="margin-bottom: 0cm"><FONT FACE="AR PL ZenKai Uni, serif"><SPAN LANG="en-US">==3649==
   at 0x80483CF: f (in /home/wangcong/memleak)</SPAN></FONT></P>
<P CLASS="cjk" STYLE="margin-bottom: 0cm"><FONT FACE="AR PL ZenKai Uni, serif"><SPAN LANG="en-US">==3649==
   by 0x80483EC: main (in /home/wangcong/memleak)</SPAN></FONT></P>
<P CLASS="cjk" STYLE="margin-bottom: 0cm"><FONT FACE="AR PL ZenKai Uni, serif"><SPAN LANG="en-US">==3649==
 Address 0x4024050 is 0 bytes after a block of size 40 alloc'd</SPAN></FONT></P>
<P CLASS="cjk" STYLE="margin-bottom: 0cm"><FONT FACE="AR PL ZenKai Uni, serif"><SPAN LANG="en-US">==3649==
   at 0x40051F9: malloc (vg_replace_malloc.c:149)</SPAN></FONT></P>
<P CLASS="cjk" STYLE="margin-bottom: 0cm"><FONT FACE="AR PL ZenKai Uni, serif"><SPAN LANG="en-US">==3649==
   by 0x80483C5: f (in /home/wangcong/memleak)</SPAN></FONT></P>
<P CLASS="cjk" STYLE="margin-bottom: 0cm"><FONT FACE="AR PL ZenKai Uni, serif"><SPAN LANG="en-US">==3649==
   by 0x80483EC: main (in /home/wangcong/memleak)</SPAN></FONT></P>
<P CLASS="cjk" STYLE="margin-bottom: 0cm"><BR>
</P>
<P CLASS="cjk" STYLE="margin-bottom: 0cm">前面的<FONT FACE="AR PL ZenKai Uni, serif"><SPAN LANG="en-US">3649</SPAN></FONT>是程序运行时的进程号。第一行是告诉我们错误类型，这里是非法写入。下面的是告诉我们错误发生的位置，在<FONT FACE="AR PL ZenKai Uni, serif"><SPAN LANG="en-US">main()</SPAN></FONT>调用的<FONT FACE="AR PL ZenKai Uni, serif"><SPAN LANG="en-US">f()</SPAN></FONT>函数中。</P>
<P CLASS="cjk" STYLE="margin-bottom: 0cm"><BR>
</P>
<P CLASS="cjk" STYLE="margin-bottom: 0cm"><FONT FACE="AR PL ZenKai Uni, serif"><SPAN LANG="en-US">==3649==
Use of uninitialised value of size 4</SPAN></FONT></P>
<P CLASS="cjk" STYLE="margin-bottom: 0cm"><FONT FACE="AR PL ZenKai Uni, serif"><SPAN LANG="en-US">==3649==
   at 0xC3A264: _itoa_word (in /lib/libc-2.4.so)</SPAN></FONT></P>
<P CLASS="cjk" STYLE="margin-bottom: 0cm"><FONT FACE="AR PL ZenKai Uni, serif"><SPAN LANG="en-US">==3649==
   by 0xC3E25C: vfprintf (in /lib/libc-2.4.so)</SPAN></FONT></P>
<P CLASS="cjk" STYLE="margin-bottom: 0cm"><FONT FACE="AR PL ZenKai Uni, serif"><SPAN LANG="en-US">==3649==
   by 0xC442B6: printf (in /lib/libc-2.4.so)</SPAN></FONT></P>
<P CLASS="cjk" STYLE="margin-bottom: 0cm"><FONT FACE="AR PL ZenKai Uni, serif"><SPAN LANG="en-US">==3649==
   by 0x80483FF: main (in /home/wangcong/memleak)</SPAN></FONT></P>
<P CLASS="cjk" STYLE="margin-bottom: 0cm"><BR>
</P>
<P CLASS="cjk" STYLE="margin-bottom: 0cm">这个错误是使用未初始化的值，在<FONT FACE="AR PL ZenKai Uni, serif"><SPAN LANG="en-US">main()</SPAN></FONT>调用的<FONT FACE="AR PL ZenKai Uni, serif"><SPAN LANG="en-US">printf()</SPAN></FONT>函数中。这里的函数调用关系是通过堆栈跟踪的，所以有时会非常多，尤其是当你使用<FONT FACE="AR PL ZenKai Uni, serif"><SPAN LANG="en-US">C++</SPAN></FONT>的<FONT FACE="AR PL ZenKai Uni, serif"><SPAN LANG="en-US">STL</SPAN></FONT>时。其它一些错误都是由于把未初始化的值传递给<FONT FACE="AR PL ZenKai Uni, serif"><SPAN LANG="en-US">libc</SPAN></FONT>函数而被检测到。在程序运行结束后，<FONT FACE="AR PL ZenKai Uni, serif"><SPAN LANG="en-US">valgrind</SPAN></FONT>还给出了一个小的总结：</P>
<P CLASS="cjk" STYLE="margin-bottom: 0cm"><BR>
</P>
<P CLASS="cjk" STYLE="margin-bottom: 0cm"><FONT FACE="AR PL ZenKai Uni, serif"><SPAN LANG="en-US">==3649==
ERROR SUMMARY: 20 errors from 6 contexts (suppressed: 12 from 1)</SPAN></FONT></P>
<P CLASS="cjk" STYLE="margin-bottom: 0cm"><FONT FACE="AR PL ZenKai Uni, serif"><SPAN LANG="en-US">==3649==
malloc/free: in use at exit: 40 bytes in 1 blocks.</SPAN></FONT></P>
<P CLASS="cjk" STYLE="margin-bottom: 0cm"><FONT FACE="AR PL ZenKai Uni, serif"><SPAN LANG="en-US">==3649==
malloc/free: 1 allocs, 0 frees, 40 bytes allocated.</SPAN></FONT></P>
<P CLASS="cjk" STYLE="margin-bottom: 0cm"><FONT FACE="AR PL ZenKai Uni, serif"><SPAN LANG="en-US">==3649==
For counts of detected errors, rerun with: -v</SPAN></FONT></P>
<P CLASS="cjk" STYLE="margin-bottom: 0cm"><FONT FACE="AR PL ZenKai Uni, serif"><SPAN LANG="en-US">==3649==
searching for pointers to 1 not-freed blocks.</SPAN></FONT></P>
<P CLASS="cjk" STYLE="margin-bottom: 0cm"><FONT FACE="AR PL ZenKai Uni, serif"><SPAN LANG="en-US">==3649==
checked 47,256 bytes.</SPAN></FONT></P>
<P CLASS="cjk" STYLE="margin-bottom: 0cm"><FONT FACE="AR PL ZenKai Uni, serif"><SPAN LANG="en-US">==3649==</SPAN></FONT></P>
<P CLASS="cjk" STYLE="margin-bottom: 0cm"><FONT FACE="AR PL ZenKai Uni, serif"><SPAN LANG="en-US">==3649==
LEAK SUMMARY:</SPAN></FONT></P>
<P CLASS="cjk" STYLE="margin-bottom: 0cm"><FONT FACE="AR PL ZenKai Uni, serif"><SPAN LANG="en-US">==3649==
   definitely lost: 40 bytes in 1 blocks.</SPAN></FONT></P>
<P CLASS="cjk" STYLE="margin-bottom: 0cm"><FONT FACE="AR PL ZenKai Uni, serif"><SPAN LANG="en-US">==3649==
     possibly lost: 0 bytes in 0 blocks.</SPAN></FONT></P>
<P CLASS="cjk" STYLE="margin-bottom: 0cm"><FONT FACE="AR PL ZenKai Uni, serif"><SPAN LANG="en-US">==3649==
   still reachable: 0 bytes in 0 blocks.</SPAN></FONT></P>
<P CLASS="cjk" STYLE="margin-bottom: 0cm"><FONT FACE="AR PL ZenKai Uni, serif"><SPAN LANG="en-US">==3649==
        suppressed: 0 bytes in 0 blocks.</SPAN></FONT></P>
<P CLASS="cjk" STYLE="margin-bottom: 0cm"><FONT FACE="AR PL ZenKai Uni, serif"><SPAN LANG="en-US">==3649==
Use --leak-check=full to see details of leaked memory.</SPAN></FONT></P>
<P CLASS="cjk" STYLE="margin-bottom: 0cm"><BR>
</P>
<P CLASS="cjk" STYLE="margin-bottom: 0cm">我们可以很清楚地看出，分配和释放了多少内存，有多少内存泄漏。这对我们查找内存泄漏十分方便。然后我们重新编译程序并绑定调试器：</P>
<P CLASS="cjk" STYLE="margin-bottom: 0cm"><BR>
</P>
<P CLASS="cjk" STYLE="margin-bottom: 0cm"><FONT FACE="AR PL ZenKai Uni, serif"><SPAN LANG="en-US">$
gcc -Wall -ggdb -o memleak memleak.c</SPAN></FONT></P>
<P CLASS="cjk" STYLE="margin-bottom: 0cm"><FONT FACE="AR PL ZenKai Uni, serif"><SPAN LANG="en-US">$
valgrind --db-attach=yes --tool=memcheck ./memleak</SPAN></FONT></P>
<P CLASS="cjk" STYLE="margin-bottom: 0cm"><BR>
</P>
<P CLASS="cjk" STYLE="margin-bottom: 0cm">一出现错误，<FONT FACE="AR PL ZenKai Uni, serif"><SPAN LANG="en-US">valgrind</SPAN></FONT>会自动启动调试器（一般是<FONT FACE="AR PL ZenKai Uni, serif"><SPAN LANG="en-US">gdb</SPAN></FONT>）：</P>
<P CLASS="cjk" STYLE="margin-bottom: 0cm"><BR>
</P>
<P CLASS="cjk" STYLE="margin-bottom: 0cm"><FONT FACE="AR PL ZenKai Uni, serif"><SPAN LANG="en-US">==3893==
---- Attach to debugger ? --- [Return/N/n/Y/y/C/c] ---- y</SPAN></FONT></P>
<P CLASS="cjk" STYLE="margin-bottom: 0cm"><FONT FACE="AR PL ZenKai Uni, serif"><SPAN LANG="en-US">starting
debugger</SPAN></FONT></P>
<P CLASS="cjk" STYLE="margin-bottom: 0cm"><FONT FACE="AR PL ZenKai Uni, serif"><SPAN LANG="en-US">==3893==
starting debugger with cmd: /usr/bin/gdb -nw /proc/3895/fd/1014 3895</SPAN></FONT></P>
<P CLASS="cjk" STYLE="margin-bottom: 0cm"><BR>
</P>
<P CLASS="cjk" STYLE="margin-bottom: 0cm">退出<FONT FACE="AR PL ZenKai Uni, serif"><SPAN LANG="en-US">gdb</SPAN></FONT>后我们又能回到<FONT FACE="AR PL ZenKai Uni, serif"><SPAN LANG="en-US">valgrind</SPAN></FONT>继续执行程序。</P>
<P CLASS="cjk" STYLE="margin-bottom: 0cm"><BR>
</P>
<P CLASS="cjk" STYLE="margin-bottom: 0cm">    
还是用上面的程序，我们使用<FONT FACE="AR PL ZenKai Uni, serif"><SPAN LANG="en-US">callgrind</SPAN></FONT>来分析一下它的效率：</P>
<P CLASS="cjk" STYLE="margin-bottom: 0cm"><BR>
</P>
<P CLASS="cjk" STYLE="margin-bottom: 0cm"><FONT FACE="AR PL ZenKai Uni, serif"><SPAN LANG="en-US">$
valgrind --tool=callgrind ./memleak</SPAN></FONT></P>
<P CLASS="cjk" STYLE="margin-bottom: 0cm"><BR>
</P>
<P CLASS="cjk" STYLE="margin-bottom: 0cm"><FONT FACE="AR PL ZenKai Uni, serif"><SPAN LANG="en-US">Callgrind</SPAN></FONT>会输出很多，而且最后在当前目录下生成一个文件：
<FONT FACE="AR PL ZenKai Uni, serif"><SPAN LANG="en-US">callgrind.out.<I>pid</I></SPAN></FONT>。用<FONT FACE="AR PL ZenKai Uni, serif"><SPAN LANG="en-US">callgrind_annotate</SPAN></FONT>来查看它：</P>
<P CLASS="cjk" STYLE="margin-bottom: 0cm"><BR>
</P>
<P CLASS="cjk" STYLE="margin-bottom: 0cm"><FONT FACE="AR PL ZenKai Uni, serif"><SPAN LANG="en-US">$
callgrind_annotate callgrind.out.3949</SPAN></FONT></P>
<P CLASS="cjk" STYLE="margin-bottom: 0cm"><BR>
</P>
<P CLASS="cjk" STYLE="margin-bottom: 0cm">详细的信息就列出来了。而且，当<FONT FACE="AR PL ZenKai Uni, serif"><SPAN LANG="en-US">callgrind</SPAN></FONT>运行你的程序时，你还可以使用<FONT FACE="AR PL ZenKai Uni, serif"><SPAN LANG="en-US">callgrind_control</SPAN></FONT>来观察程序的执行，而且不会干扰它的运行。</P>
<P CLASS="cjk" STYLE="margin-bottom: 0cm"><BR>
</P>
<P CLASS="cjk" STYLE="margin-bottom: 0cm">    再来看一下<FONT FACE="AR PL ZenKai Uni, serif"><SPAN LANG="en-US">cachegrind</SPAN></FONT>的表现：</P>
<P CLASS="cjk" STYLE="margin-bottom: 0cm"><FONT FACE="AR PL ZenKai Uni, serif"><SPAN LANG="en-US">$
valgrind --tool=cachegrind ./memleak</SPAN></FONT></P>
<P CLASS="cjk" STYLE="margin-bottom: 0cm"><BR>
</P>
<P CLASS="cjk" STYLE="margin-bottom: 0cm">得到如下信息：</P>
<P CLASS="cjk" STYLE="margin-bottom: 0cm"><FONT FACE="AR PL ZenKai Uni, serif"><SPAN LANG="en-US">==4073==
I   refs:      147,500</SPAN></FONT></P>
<P CLASS="cjk" STYLE="margin-bottom: 0cm"><FONT FACE="AR PL ZenKai Uni, serif"><SPAN LANG="en-US">==4073==
I1  misses:      1,189</SPAN></FONT></P>
<P CLASS="cjk" STYLE="margin-bottom: 0cm"><FONT FACE="AR PL ZenKai Uni, serif"><SPAN LANG="en-US">==4073==
L2i misses:        679</SPAN></FONT></P>
<P CLASS="cjk" STYLE="margin-bottom: 0cm"><FONT FACE="AR PL ZenKai Uni, serif"><SPAN LANG="en-US">==4073==
I1  miss rate:    0.80%</SPAN></FONT></P>
<P CLASS="cjk" STYLE="margin-bottom: 0cm"><FONT FACE="AR PL ZenKai Uni, serif"><SPAN LANG="en-US">==4073==
L2i miss rate:    0.46%</SPAN></FONT></P>
<P CLASS="cjk" STYLE="margin-bottom: 0cm"><FONT FACE="AR PL ZenKai Uni, serif"><SPAN LANG="en-US">==4073==</SPAN></FONT></P>
<P CLASS="cjk" STYLE="margin-bottom: 0cm"><FONT FACE="AR PL ZenKai Uni, serif"><SPAN LANG="en-US">==4073==
D   refs:       61,920  (46,126 rd + 15,794 wr)</SPAN></FONT></P>
<P CLASS="cjk" STYLE="margin-bottom: 0cm"><FONT FACE="AR PL ZenKai Uni, serif"><SPAN LANG="en-US">==4073==
D1  misses:      1,759  ( 1,545 rd +    214 wr)</SPAN></FONT></P>
<P CLASS="cjk" STYLE="margin-bottom: 0cm"><FONT FACE="AR PL ZenKai Uni, serif"><SPAN LANG="en-US">==4073==
L2d misses:      1,241  ( 1,062 rd +    179 wr)</SPAN></FONT></P>
<P CLASS="cjk" STYLE="margin-bottom: 0cm"><FONT FACE="AR PL ZenKai Uni, serif"><SPAN LANG="en-US">==4073==
D1  miss rate:     2.8% (   3.3%   +    1.3%  )</SPAN></FONT></P>
<P CLASS="cjk" STYLE="margin-bottom: 0cm"><FONT FACE="AR PL ZenKai Uni, serif"><SPAN LANG="en-US">==4073==
L2d miss rate:     2.0% (   2.3%   +    1.1%  )</SPAN></FONT></P>
<P CLASS="cjk" STYLE="margin-bottom: 0cm"><FONT FACE="AR PL ZenKai Uni, serif"><SPAN LANG="en-US">==4073==</SPAN></FONT></P>
<P CLASS="cjk" STYLE="margin-bottom: 0cm"><FONT FACE="AR PL ZenKai Uni, serif"><SPAN LANG="en-US">==4073==
L2 refs:         2,948  ( 2,734 rd +    214 wr)</SPAN></FONT></P>
<P CLASS="cjk" STYLE="margin-bottom: 0cm"><FONT FACE="AR PL ZenKai Uni, serif"><SPAN LANG="en-US">==4073==
L2 misses:       1,920  ( 1,741 rd +    179 wr)</SPAN></FONT></P>
<P CLASS="cjk" STYLE="margin-bottom: 0cm"><FONT FACE="AR PL ZenKai Uni, serif"><SPAN LANG="en-US">==4073==
L2 miss rate:      0.9% (   0.8%   +    1.1%  )</SPAN></FONT></P>
<P CLASS="cjk" STYLE="margin-bottom: 0cm"><BR>
</P>
<P CLASS="cjk" STYLE="margin-bottom: 0cm">上面的是指令缓存，<FONT FACE="AR PL ZenKai Uni, serif"><SPAN LANG="en-US">I1</SPAN></FONT>和<FONT FACE="AR PL ZenKai Uni, serif"><SPAN LANG="en-US">L2i</SPAN></FONT>缓存，的访问信息，包括总的访问次数，丢失次数，丢失率。</P>
<P CLASS="cjk" STYLE="margin-bottom: 0cm">中间的是数据缓存，<FONT FACE="AR PL ZenKai Uni, serif"><SPAN LANG="en-US">D1</SPAN></FONT>和<FONT FACE="AR PL ZenKai Uni, serif"><SPAN LANG="en-US">L2d</SPAN></FONT>缓存，的访问的相关信息，下面的<FONT FACE="AR PL ZenKai Uni, serif"><SPAN LANG="en-US">L2</SPAN></FONT>缓存单独的信息。<FONT FACE="AR PL ZenKai Uni, serif"><SPAN LANG="en-US">Cachegrind</SPAN></FONT>也生成一个文件，名为<FONT FACE="AR PL ZenKai Uni, serif"><SPAN LANG="en-US">cachegrind.out.<I>pid</I></SPAN></FONT><I>，</I><SPAN STYLE="font-style: normal">可以通过</SPAN><FONT FACE="AR PL ZenKai Uni, serif"><SPAN LANG="en-US"><SPAN STYLE="font-style: normal">cg_annotate</SPAN></SPAN></FONT><SPAN STYLE="font-style: normal">来读取。输出是一个更详细的列表。</SPAN><FONT FACE="AR PL ZenKai Uni, serif"><SPAN LANG="en-US"><SPAN STYLE="font-style: normal">Massif</SPAN></SPAN></FONT><SPAN STYLE="font-style: normal">的使用和</SPAN><FONT FACE="AR PL ZenKai Uni, serif"><SPAN LANG="en-US"><SPAN STYLE="font-style: normal">cachegrind</SPAN></SPAN></FONT><SPAN STYLE="font-style: normal">类似，不过它也会生成一个名为</SPAN><FONT FACE="AR PL ZenKai Uni, serif"><SPAN LANG="en-US"><SPAN STYLE="font-style: normal">massif.</SPAN><I>pid</I><SPAN STYLE="font-style: normal">.ps</SPAN></SPAN></FONT><SPAN STYLE="font-style: normal">的</SPAN><FONT FACE="AR PL ZenKai Uni, serif"><SPAN LANG="en-US"><SPAN STYLE="font-style: normal">PostScript</SPAN></SPAN></FONT><SPAN STYLE="font-style: normal">文件，里面只有一幅描述堆栈使用状况的彩图。</SPAN></P>
<P CLASS="cjk" STYLE="margin-bottom: 0cm"><FONT COLOR="#000000">   
<SPAN STYLE="font-style: normal"><SPAN LANG="zh-CN"><FONT SIZE=3>以上只是简单的演示了</FONT></FONT></SPAN></SPAN><FONT FACE="AR PL ZenKai Uni, serif"><SPAN LANG="en-US"><SPAN STYLE="font-style: normal"><SPAN LANG="en-US"><FONT SIZE=3><FONT COLOR="#000000">valgrind</FONT></FONT></SPAN></SPAN></SPAN></FONT><SPAN STYLE="font-style: normal"><SPAN LANG="zh-CN"><FONT SIZE=3><FONT COLOR="#000000">的使用，更多的信息可以在它附带的文档中得到，也可以访问</FONT></FONT></SPAN></SPAN><FONT FACE="AR PL ZenKai Uni, serif"><SPAN LANG="en-US"><SPAN STYLE="font-style: normal"><SPAN LANG="en-US"><FONT SIZE=3><FONT COLOR="#000000">valgrind</FONT></FONT></SPAN></SPAN></SPAN></FONT><SPAN STYLE="font-style: normal"><SPAN LANG="zh-CN"><FONT SIZE=3><FONT COLOR="#000000">的主页：</FONT></FONT></SPAN></SPAN><FONT FACE="AR PL ZenKai Uni, serif"><SPAN LANG="en-US"><SPAN STYLE="font-style: normal"><SPAN LANG="en-US"><FONT SIZE=3><FONT COLOR="#000000">http://www.valgrind.org</FONT></FONT></SPAN></SPAN></SPAN></FONT><SPAN STYLE="font-style: normal"><SPAN LANG="zh-CN"><FONT SIZE=3><FONT COLOR="#000000">。学会正确合理地使用</FONT></FONT></SPAN></SPAN><FONT FACE="AR PL ZenKai Uni, serif"><SPAN LANG="en-US"><SPAN STYLE="font-style: normal"><SPAN LANG="en-US"><FONT SIZE=3><FONT COLOR="#000000">valgrind</FONT></FONT></SPAN></SPAN></SPAN></FONT><SPAN STYLE="font-style: normal"><SPAN LANG="zh-CN"><FONT SIZE=3><FONT COLOR="#000000">对于调试程序会有很大的帮助。</FONT></FONT></SPAN></SPAN></P>
</BODY>
</HTML>